{
  "hash": "848324d4722fb3ebad83bcea5f89ebef",
  "result": {
    "markdown": "---\ntitle: Principles and elements of visualisations\nformat:\n  html:\n    code-fold: true\n    code-tools: true\nexecute: \n  warning: false\n---\n\n\n::: {.callout-warning appearance=\"simple\"}\nThis site and its content are in development. The authors welcome feedback. Please either \\[insert info about raising an issue/PR/email etc.\\]\n:::\n\nData visualisations must serve a purpose. By understanding the purpose of a visualisation, we -- as author or reader -- are in a position to assess whether a visualisation succeeds in its aims or requires improvement.\n\nArguably the most common purpose of a visualisation is a comparison of groups of data, such as data on patients receiving different treatments. A good choice of axes, axis limits, labels and symbols can facilitate substantially the identification of patterns in the data, whereas  poor choices for any of these elements can substantially hamper the extraction of information.\n\n## Elements of charts\n\nVarious elements of a visualisation can contribute to the efficacy with which information can be distilled. All visualisation software packages will output graphics in a default style, but these will rarely, if ever, be the optimum choices for the data visualisation you are creating. When designing a data visualisation, one needs to consider the range of options available. Some of these options are discussed in what follows.\n\n### Layout (panels, facets)\n\nThe layout (arrangement of multiple panels, facets, or subplots) is highly relevant for efficient comparison. If data on the y-axis are to be compared, a single y-axis with all panels aligned horizontally facilitates comparison, whereas for efficient comparison of x-axis values, panels should be stacked. Matrix layouts (multiple rows and columns in a single figure) should only be used if the data shown in individual panels are not related or space does not permit a single row or a single column (e.g., if there are too many panels to fit on a single row).\n\n**Example:** The figure below shows two different layouts of exactly the same data with exactly the same type of visualisation except for the layout. Note how difficult it is to compare the data across panels on the left-hand side, while it is easy with the layout on the right-hand side. The key difference is that the panels on the right share a common y-axis, which is key for comparison of y-values across panels.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ---\n# Data set creation.\n\nset.seed(93384)\n\ntime <- c(0, 0.5, 1, 2, 4, 8, 12, 16, 24)\nn <- 32 # no of subjects\n\ndata <- expand.grid(ID=1:n, time=time)\n\nbw <- data.frame(\n\tID=sort(unique(data$ID)),\n\tbw=rlnorm(n, log(75), sdlog=0.25)\n)\n\nbw$bw.category <- cut(bw$bw,\n\tbreaks=quantile(bw$bw, c(0, 0.33, 0.66, 1)), \n\tlabels=paste(c(\"low\", \"medium\", \"high\"), \"body weight\"), \n\tinclude.lowest=TRUE)\n\ndata <- merge(data, bw)\n\ndata <- data[order(data$ID, data$time), ]\n\n# Simulate drug concentrations as a function of body weight.\ndata$conc <- 100/(data$bw^1.0)*exp(-0.085*data$time)*\n\trlnorm(nrow(data), sdlog=0.25)+ # res. error\n\t(data$ID-mean(data$ID))/mean(data$ID)/4 # r. eff\n\n# ---\n# Visualisation.\nlibrary(ggplot2)\n\ngg <- list()\n\ndata$ID <- factor(data$ID)\n\ngg[[\"3x1\"]] <- ggplot(data, aes(x=time, y=conc, group=ID, color=ID)) + geom_line() \ngg[[\"3x1\"]] <- gg[[\"3x1\"]] + scale_x_continuous(breaks=seq(0, 24, by=4)) \ngg[[\"3x1\"]] <- gg[[\"3x1\"]] + theme_bw() + xlab(\"time [h]\") + ylab(\"drug concentration [ng/mL]\")\ngg[[\"3x1\"]] <- gg[[\"3x1\"]] + facet_grid(bw.category ~ .)\ngg[[\"3x1\"]] <- gg[[\"3x1\"]] + theme(legend.position=\"none\")\n\ngg[[\"1x3\"]] <- gg[[\"3x1\"]] + facet_grid(. ~ bw.category)\n\n# Add space to the rhs of the first figure for better separation in the cowplot.\ngg[[\"3x1\"]] <- gg[[\"3x1\"]] + theme(plot.margin = unit(c(0.5, 4, 0.5, 0.5), \"lines\"))\n\n\n# print(gg)\n\n# ---\n# Both figures into a single output figure.\n\nlibrary(cowplot)\nplot_grid(gg[[1]], gg[[2]], rel_widths=c(1.5, 2))\n```\n\n::: {.cell-output-display}\n![](principles_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n::: figure-caption\nChoice of layout determines ease of comparison across panels\n:::\n\n### Aspect ratio\n\nOur visual perception of data in a display must not depend on the choice of x- and y-axes. In many cases, a square figure avoids visual bias. A square figure should be considered in particular if the two axes share a communality such as a measurement before and after some event, observed data vs model-predicted values or, more generally, the same units (such as kg or metres). Generally, a 1:1 aspect ratio (the physical length of 1 measurement unit in the x- and the y-direction) is a good default. If the figure has identical ranges for the x- and the y-axis, a 1:1 aspect ratio yields a square figure.\n\n**Example:** The three panels below all show the same data, aiming at enabling judgement about the goodness of a model fit (predicted vs observed values). Note the difference in visual perception between a stretched x-axis, a stretched y-axis, and a 1:1 aspect ratio (i.e., one unit in x and y corresponds to the same number of pixels) and identical axis limits (such that the figure is square). Other applications: any x and y that are to be compared.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Observed vs predicted (any data with comparable x and y will do).\n\n# ---\n# Data set.\n# Old Faithful Geyser (Yellowstone) data set with eruption duration\n#   and waiting time to the next eruption (both in minutes).\ndata <- data.frame(\n\tx=faithful$eruptions,\n\ty=faithful$waiting\n)\n\n# ---\n# Regression model fit.\nfit <- lm(y ~ x, data=data)\n\n# Addition of predicted values to the data set.\ndata$pred <- predict(fit)\n\n# Range of y and y predicted combined.\nr <- range(unlist(data[c(\"y\", \"pred\")]))\n\n# ---\n# Plotting.\n\nlibrary(ggplot2)\n\ngg <- ggplot(data, aes(x=pred, y=y))\n\n# Adding the line of identity, y=x (note: plotting it first will add points on top).\ngg <- gg + geom_abline(intercept=0, slope=1, color=\"black\", linewidth=1)\n\n# Adding points, removing grey background.\ngg <- gg + geom_point() + theme_bw() \n\n# Adding linear OLS regression fit of y~x.\ngg <- gg + geom_smooth(method=\"loess\", color=\"firebrick\", se=FALSE)\n\n# Adding axis labels.\ngg <- gg + xlab(\"predicted\") + ylab(\"observed\")\n\n# Transpose (flip coordinates)\ngg2 <- gg + coord_flip()\n\n# Setting the aspect ratio to 1 (1 unit in x and y corresponds\n#   to the same number of pixels).\ngg3 <- gg + coord_fixed()\n\n# Defining identical axis limits for x and y.\ngg3 <- gg3 + xlim(r) + ylim(r)\n\n# Cow (column-wise) plot, combine all figures into one.\nlibrary(cowplot)\nplot_grid(gg, gg2, gg3, rel_widths=c(4, 2, 2), nrow=1)\n```\n\n::: {.cell-output-display}\n![](principles_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n::: figure-caption\nVisual perception is influenced by aspect ratio\n:::\n\n### Lines\n\nLines introduce an order, a sequence. If there is no order, data should not be interconnected by lines. If different line types indicate different groups that have an inherent order, it is helpful if the chosen line styles have an order, too (example: line thickness, dash density, or darkness of colour increases with values from the lowest to the highest group).\n\n### Points\n\nPoint symbols should be chosen such that the visualisation displays the data in a meaningful way. If thousands of data points are to be shown, open circles or smaller filled symbols are better than overlapping filled symbols. If the data are discrete and observations overlay, consider jittering the data gently for a better visualisation.\n\n### Colours\n\nColours should serve a purpose such as helping to identify different groups. Colours for pure decoration are discouraged. Cleveland pointed out that because \"they do have a natural visual hierarchy, varying shades of gray show varying quantities better than color\", and \"the shades of gray provide an easily comprehended order to the data measures. This is the key\" (Cleveland 2001, p. 154).\n\n### Axes\n\n#### Origins and limits\n\nAxis ranges should generally start at 0 unless there is a good reason for choosing other ranges. If the data do not contain negative values, the axis should not stretch into negative values and in particular not have tick marks at negative values.\n\nIf relative changes or ratios are displayed, the corresponding axis should be logarithmic (such that, e.g., 1/4 has the same distance to the reference point, 1, as 4) and symmetric around the point of no change. An auxiliary line at the point of no change can facilitate interpretation. Axis tickmarks and auxiliary grey lines will facilitate reading off values, avoiding wrong linear interpolation by the viewer. Axis tick mark labels should indicate the ratio (e..g, \"1/4\" instead of 0.25).\n\nIf the data displayed as x and as y are comparable, axis limits should be identical and the figure square, such that distances are consistent in the x- and in the y-direction.\n\n**Example:** The figure below illustrates that the deliberate choice of axis limits (here, y-axis limits) can make a big difference to perception, and therefore interpretation, by the reader. The only difference between the two panels is the y-axis range.\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nplot_data <- data.frame(type = factor(\n      c(\"Our product\", \"Competitor\"),\n      levels = c(\"Our product\", \"Competitor\")),\n      value = c(220, 210))\n\n# Original plot\nggplot(plot_data) +\n      geom_col(\n            mapping=aes(x=type, y=value),\n            fill=\"lightblue\",\n            colour=\"black\"\n  ) +\n      scale_y_continuous(breaks=seq(0, 220, by=20), expand=c(0, 0)) +\n      labs(x=\"\", y=\"\") + theme_minimal()\n```\n\n::: {.cell-output-display}\n![](principles_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Offset the y axis\noffset <- 208\nggplot(plot_data) +\n      geom_col(\n            mapping = aes(x=type, y=value-offset),\n            fill=\"lightblue\",\n            colour=\"black\"\n  ) +\n  scale_y_continuous(breaks=seq(0, 14, by=2),\n                     labels=seq(0+offset, 14 + offset, by=2),\n                     expand=c(0, 0)) +\n      labs(x=\"\", y=\"\") +\n      theme_minimal()\n```\n\n::: {.cell-output-display}\n![](principles_files/figure-html/unnamed-chunk-3-2.png){width=672}\n:::\n:::\n\n\n::: figure-caption\nVisual impression can be driven by the choice of axis limits\n:::\n\n#### Linear and logarithmic axes\n\n**Example:** Let's say that you want to know whether some variable, y, changes (compared to a reference or baseline measurement) depending on another variable, x. For example, does blood pressure change with treatment?\n\nThe figure below shows data with, on average, no change compared to a reference (baseline) measurement (red horizontal line) -- approximately half the data are below and above the point of no change. However, this is not easily apparent from the top-left panel, which uses a linear axis, and so space is allocated asymmetrically in the vertical direction \\-- both up and down -- away from the reference line. In the top-right panel, which uses a logarithmic axis, the relatively even spread of the data points around the reference line is clear to see.\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\n# Naïve plot of y vs x. If there is no change (on average), \n# half the data are below the line of no change.\n# Asymmetric view, and it depends on y/x or x/y.\n\nset.seed(33838)\nx <- data.frame(\n  x=rlnorm(200, 2, 0.2),\n  y=rlnorm(200, 0.2, 0.75)\n)\n# Add an outlier manually.\nx <- rbind(x, data.frame(x=quantile(x$x, 0.8), y=max(x$y)*1.5))\n\n# ---\n# Plotting.\n\nlibrary(ggplot2)\n# Scatterplot of y vs x.\ngg <- ggplot(x, aes(x=x, y=y)) + geom_point() + theme_bw()\ngg <- gg + geom_hline(yintercept=1, color=\"firebrick\", linewidth=2)\ngg <- gg + xlab(\"x-variable\") + ylab(\"Fold-change\")\ngg\n```\n\n::: {.cell-output-display}\n![](principles_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Logarithmic axes, symmetric range (!):\nxbr <- c(1/10, 1/5, 1/2, 1, 2, 5, 10)\ngg <- gg + scale_y_continuous(breaks=xbr, trans=\"log10\",\n  limits=max(abs(x$y))^c(-1, 1))\nprint(gg)\n```\n\n::: {.cell-output-display}\n![](principles_files/figure-html/unnamed-chunk-4-2.png){width=672}\n:::\n\n```{.r .cell-code}\n# Second axis:\ngg <- gg + scale_y_continuous(\n  breaks=xbr,\n  labels=paste(100*xbr, \"%\", sep=\"\"),\n  trans=\"log10\",\n  limits=max(abs(x$y))^c(-1, 1),\n  sec.axis=sec_axis(trans=~.*1, breaks=xbr,\n  labels=ifelse(xbr < 1, paste(\"1/\", 1/xbr, sep=\"\"), xbr))\n)\n\n# ---\n# Univariate distribution (histogram).\n\ngg <- ggplot(x, aes(x=y)) + theme_bw() + xlab(\"Fold-change\")\ngg <- gg + geom_histogram(color=\"firebrick\", fill=\"gray\")\nprint(gg)\n```\n\n::: {.cell-output-display}\n![](principles_files/figure-html/unnamed-chunk-4-3.png){width=672}\n:::\n\n```{.r .cell-code}\n# Symmetric range, log scale.\ngg <- gg + scale_x_continuous(\n  breaks=xbr,\n  labels=ifelse(xbr < 1, paste(\"1/\", 1/xbr), xbr),\n  trans=\"log10\",\n  limits=max(abs(x$x))^c(-1, 1)\n)\nprint(gg)\n```\n\n::: {.cell-output-display}\n![](principles_files/figure-html/unnamed-chunk-4-4.png){width=672}\n:::\n:::\n\n\n::: figure-caption\n\\[caption to be added\\]\n:::\n\n### Symbols\n\nSymbols should be intuitive (for example, \"+\" for a positive outcome, \"-\" for a negative outcome, \"O\" for a neutral outcome). In an ideal case, symbols require only a single look at the legend to subsequently focus on the visualisation. \n\nSymbols such as triangles, circles, and squares do not have an intuitive connotation. However, if there is an order in the data, it might be reflected in the order of the symbols, e.g., the number of vertices (circle, dash, triangle, square, pentagon, etc.).\n\n### Legends\n\nLegends should not attract too much attention and certainly not cover up data. They should be placed in the margins of the figure or can be captured in a small text below the figure. \n\nIf legend entries refer to single objects (e.g., one line per group), placing the legend next to the corresponding object makes it easier for the reader to map legend entries to display objects.\n\n**Example:** The figure below shows that ease of reading can be improved by adding the legend directly into the figure, next to the corresponding data. Note that labels must not overlay and label positions might require adaptation depending on the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ---\n# EU stock markets, year and indices DAX, SMI, CAC, and FTSE.\n\n# Store graphics into a list.\ngg.list <- list()\n\n# Prepare the data set (reformat EuStockMarkets that comes with R).\nx <- EuStockMarkets\ndf <- data.frame(\n    time=as.vector(time(x)),\n    index=rep(colnames(x), rep(nrow(x), ncol(x))),\n    value=as.vector(x)\n)\ndf$index2 <- df$index # For use with labels later.\n\nlibrary(ggplot2)\n\n# Standard layout and legend.\ngg <- ggplot(df, aes(x=time, y=value, group=index, color=index, label=index2))\ngg <- gg + geom_line() + theme_bw()\n\n# Nicer axis tick mark settings.\nax <- pretty(df$time, n=10)\ngg <- gg + scale_x_continuous(limits=range(ax), breaks=ax)\ngg <- gg + xlab(\"year\") + ylab(\"Stock index\")\n\ngg.list[[1]] <- gg\n\n# Use the last element of each time series for x,y of the label.\n# Use that the last element is the first element of the reversed order,\n#   and extract the first element per index by using !duplicated.\ny <- df[rev(order(df$time)), ] # descending in time.\ny <- y[!duplicated(y$index), ] # first entry per index\ny$index2 <- y$index # Create a copy that contains formatted strings.\nlevels(y$index2)[levels(y$index2)==\"FTSE\"] <- \"\\n\\nFTSE\" \n\t# Add a newline to separate FTSE from DAX.\n\t# Note that the factor level is modified, not the data.\n\n# Drop the legend, move labels into figure.\ngg <- gg + geom_text(data=y, hjust=\"left\", nudge_x=0.1) \n# aes as before, nudge adds space on the lhs.\ngg <- gg + theme(legend.position=\"none\")\ngg.list[[2]] <- gg\n\n# ---\n# Both figures into a single output figure.\n\nlibrary(cowplot)\nplot_grid(gg.list[[1]], gg.list[[2]], rel_widths=c(2.25, 2))\n```\n\n::: {.cell-output-display}\n![](principles_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n::: figure-caption\nDirect labelling of figure elements can improve ease of reading\n:::\n\n### Orientation\n\nHorizontal boxplots allow for a more accurate visual comparison than vertical boxplots since it is easier for the human eye to follow an imaginary vertical line than an imaginary horizontal line.\n\nIf there is an order in the data that is to be visualised, e.g., as a barplot, showing the data as horizontal bars and sorting so as to place larger values on top is more intuitive than showing vertical bars with a left-to-right orientation (Few, 2004, p. 182).\n\n### Auxiliary elements\n\nGenerally speaking, when designing a data visualisation, we need to be wary of what Tufte calls \"chart junk\" -- any element of a chart that does not add to or enhance the information on display. Data are, of course, the star of the show, so should receive the most space. Meanwhile, all additional elements (lines, colours, symbols, etc.) should be assessed for their contribution to the interpretation of the data. If there is no contribution, they can be removed. A typical example of a redundant element in a data visualisation is a figure that has 5 panels (sub-figures or facets), each with x- and y-axis. To allow for efficient comparison of the data shown in the different panels, a single y-axis suffices if the panels are all aligned on a single row. This creates more space for the data and synchronises y-axis limits and data positions as a side benefit. \n\nSome helpful additional elements can include lines at relevant points. Examples include a vertical line at x=0 (e.g., for time 0), a horizontal line at y=0 (e.g., to indicate the point of no change, or a diagonal (at y=x, e.g., to indicate no difference between x and y). Consider whether the auxiliary element is better plotted under or over the data (which generally depends on the sequence of adding graphics elements).\n\nA local scatterplot smoother (loess, lowess, polynomial) can be particularly helpful to identify relationships with limited model assumptions. The confidence band (pointwise confidence intervals) should only be shown if relevant.\n\n**Example:** The figure below displays changes from a starting point (time 0) over time. A plain figure (left panel) requires the reader to read the y-axis labels to identify the point of no change (y=0). The addition of a line (middle panel) indicating the point of no change makes reading easier, and choosing an axis range symmetric around the point of no change (right panel) allocates increases (changes upward) to the upper half of the visualisation and decreases (changes downward) to the lower half, making reading and interpretation more intuitive.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function for data set generation.\nmake.data <- function(\n  x=c(0, 0.5, 1, 2, 4, 8, 12, 16, 24),\n  y=exp(-0.2*x) - exp(-0.21*x),\n  sd=0.25, # std dev of y\n  seed=4384590,\n  n=50\n)\n{\n  # Setting the random number seed for reproducibility.\n  set.seed(seed)\n  # Creation of x- and y-variables.\n  x2 <- rep(x, n)\n  y2 <- NULL\n  for(i in 1:n)\n    y2 <- c(y2, y*(2*(n/4-i)) + rlnorm(length(y), sd=sd))\n\n  # Creation of an identifier for each profile.\n  ID <- factor(rep(1:n, rep(length(y), n)))\n\n  # Composition of the data set.\n  df <- data.frame(PD=100*y2, time=x, ID=ID)\n\n  # Addition of a baseline variable.\n  BL <- df[df$time==0, c(\"ID\", \"PD\")]\n  names(BL) <- c(\"ID\", \"BL\")\n  df <- merge(df, BL)\n\n  # Addition of change from baseline.\n  df$Change <- df$PD - df$BL\n\n  # Definition of treatment.\n  df$trt <- ifelse(df$BL > mean(df$BL), \"active\", \" placebo\")\n\n  return(df)\n}\n\n# Generate the data.\nx <- make.data()\n\n# ---\n# Figures.\n\nlibrary(ggplot2)\ngg <- ggplot(x, aes(x=time, y=Change, group=ID, color=ID))\ngg <- gg + theme_bw()\ngg <- gg + xlab(\"Time [h]\") + ylab(\"Change from baseline\")\ngg <- gg + geom_line(linewidth=1.1) + theme(legend.position=\"none\")\ngg <- gg + facet_grid(.~trt)\n\n# Addition of an auxiliary line at y=0.\ngg2 <- gg + geom_hline(yintercept=0, linewidth=1.2)\n\n# Symmetric y-axis limits.\ngg3 <- gg2 + ylim(c(-1, 1)*max(abs(x$Change)))\n\n# Arranging all plots into one figure.\nlibrary(cowplot)\nplot_grid(gg, gg2, gg3, nrow=1)\n```\n\n::: {.cell-output-display}\n![](principles_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n::: figure-caption\n\\[caption to come\\]\n:::\n\n### Higher dimensions\n\nThree-dimensional displays of data may look striking, in some respects, but accurate reading and interpretation is not straightforward with such presentations.\n\n**Example:** The left panel of the figure below displays a single number, 10, as a 3D bar chart. The correct identification of the value is indicated by the red \"X\": the height of the bar must be projected against the rear wall (the axis) from the viewing position. The figure on the right positions bars on a tilted surface, resulting in perceived height differences when there are none: the same four numbers, 10, 20, 30, and 40, are shown in each row and column.\n\n![](images/principles-fig6.png)\n\n::: figure-caption\nReading off data values from 3D charts is difficult\n:::\n\n## Elements of tables\n\nTables can be an efficient means of visualisation, just like graphics -- and they also can be misleading or cumbersome to read if not properly presented. Tables should in particular be considered for a small number of data points or if precise numbers are to be shown. For example if numbers need to be overlaid on graphics to aid readability and interpretation (for example, appending digits to the end of the bars in a barchart), one might consider omitting the graphic entirely and displaying the numbers as a table.\n\nTables have design elements just like graphics. Some of them are discussed in the following.\n\n### Layout\n\nOne design element for tables is the layout, i.e., rows and columns. The layout should be chosen actively with the reader in mind. It is generally easier to compare numbers vertically than horizontally.\n\n### Digits\n\nThe number of digits should be consistent within a table row or column (i.e., the same variable) but can differ across variables (e.g., if the table contains small and large numbers). Unnecessary precision should be avoided, a lower number of digits might facilitate reading and comparison.\n\n### Alignment\n\nNumbers should be right-aligned to allow for easy identification of large and small numbers. In this way, large numbers literally stick out.\n\n### Multiple numbers in table cells\n\nIf table cells contain more than a single value (e.g., means and confidence intervals), it should be considered if there is a better way to display the data for easy reading. Options include splitting the numbers into multiple table cells, rows, or columns, or reducing the font size for the less relevant numbers (e.g., means might be more important than confidence intervals).\n\n### Orientation\n\nLandscape orientation is discouraged unless it cannot be avoided. Rotating a document in order to read a part of it is cumbersome for the reader, whether in print or on screen. Splitting a table into two might be a remedy to avoid landscape orientation -- but one will need to consider whether splitting the table makes important comparisons more difficult to achieve.\n\n### Fonts and colours\n\nDifferent fonts and colours can be used if these serve a purpose, such as highlighting a particular value. Use of different fonts or colours for decorative purposes is discouraged.\n",
    "supporting": [
      "principles_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}